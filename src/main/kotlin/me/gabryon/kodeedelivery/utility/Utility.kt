package me.gabryon.kodeedelivery.utility

import godot.global.GD.abs
import godot.global.GD.fmod
import godot.util.PI
import kotlin.experimental.ExperimentalTypeInference

const val DPI = PI * 2

/**
 * Adds two integers safely, ensuring no arithmetic overflow occurs.
 *
 * @param value The value to be added to this integer.
 * @return The sum of this integer and the given value. If an arithmetic overflow occurs, it returns Int.MAX_VALUE.
 */
infix fun Int.safeAdd(value: Int): Int = try {
    Math.addExact(this, value)
} catch (e: ArithmeticException) {
    Int.MAX_VALUE
}

/**
 * Calculates the value obtained by increasing the given number by a certain percentage.
 *
 * @param percentage The percentage by which the number should be increased. Typically, the number is between 1 and 100.
 * @return The value is obtained after increasing the number by the given percentage.
 */
infix fun Double.increasedBy(percentage: Double): Double = this * (1.0 + percentage / 100.0)

/**
 * Returns an infinite sequence generated by the given [block] function.
 *
 * @param block the block function to generate the sequence elements.
 * @return an infinite sequence.
 *
 * @param T the type of elements in the sequence.
 */
@OptIn(ExperimentalTypeInference::class)
fun <T> infiniteSequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence {
    iterator {
        while (true) block()
    }
}

/**
 * Executes the given block of code indefinitely in a loop.
 *
 * @param block The code block to be executed in each iteration of the loop.
 */
inline fun loop(block: () -> Unit) {
    while (true) block()
}

/**
 * Calculates the absolute angular distance between two angles.
 *
 * @param from The starting angle.
 * @param to The ending angle.
 * @return The absolute angular distance between the two angles.
 */
fun absoluteAngularDistance(from: Double, to: Double): Double {
    val angle1 = fmod(from, DPI)
    val angle2 = fmod(to, DPI)
    val diff = abs(angle1 - angle2)
    return when {
        diff > PI -> DPI - diff
        else -> diff
    }
}

/**
 * Calculates the angular distance between two angles in radians.
 *
 * @param from The starting angle.
 * @param to The ending angle.
 * @return The angular distance between the two angles.
 */
fun angularDistance(from: Double, to: Double): Double {
    val angle1 = fmod(from, DPI)
    val angle2 = fmod(to, DPI)
    val diff = angle2 - angle1
    return when {
        diff > PI -> diff - DPI
        diff < -PI -> diff + DPI
        else -> diff
    }
}